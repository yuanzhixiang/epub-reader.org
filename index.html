<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>epub reader online - Beautiful In-Browser Reading</title>
  <meta name="description" content="epub reader online is a beautiful, in-browser EPUB reader. Upload an EPUB file, parse OPF + TOC + spine in memory, navigate nested TOC nodes, and read full node-plus-children content in one continuous view." />
  <meta name="robots" content="index,follow" />
  <meta property="og:title" content="epub reader online" />
  <meta property="og:description" content="A local-first epub reader online experience that parses EPUB files in memory and renders nested TOC content in a continuous reading layout." />
  <meta property="og:type" content="website" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,400;0,700;1,400&family=Playfair+Display:ital,wght@0,400;0,600;0,700;1,400&display=swap" rel="stylesheet">
  
  <script defer data-domain="epub-reader.org" src="https://plausible.yuanzhixiang.com/js/script.js"></script>
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "epub reader online",
      "applicationCategory": "BrowserApplication",
      "operatingSystem": "Any",
      "description": "epub reader online is an in-browser tool that parses OPF, TOC, and spine, then renders full chapter content in a continuous view.",
      "featureList": [
        "Local in-memory EPUB parsing",
        "Nested TOC rendering",
        "Node and descendant chapter display",
        "Single-page continuous reading"
      ]
    }
  </script>

  <style>
    :root {
      /* Palette */
      --bg-paper: #F9F7F2;
      --bg-white: #FFFFFF;
      --text-main: #2C2C2C;
      --text-muted: #666055;
      --text-light: #8E867A;
      --accent-primary: #C07248;
      --accent-hover: #A65D35;
      --accent-soft: #F4EBE6;
      --border-soft: #EBE5DA;
      --shadow-card: 0 12px 32px rgba(40, 30, 20, 0.06);
      --shadow-hover: 0 16px 48px rgba(40, 30, 20, 0.1);
      
      /* Layout */
      --container-width: 1100px;
      --toc-width: 320px;
      
      /* Typography */
      --font-serif: "Playfair Display", serif;
      --font-sans: "Lato", "IBM Plex Sans", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background-color: var(--bg-paper);
      color: var(--text-main);
      font-family: var(--font-sans);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    [hidden] {
      display: none !important;
    }

    a {
      color: inherit;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    /* --- Start Screen / Landing Page --- */
    .start-screen {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .site-header {
      padding: 20px 40px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-width: var(--container-width);
      margin: 0 auto;
      width: 100%;
    }

    .site-brand {
      font-family: var(--font-serif);
      font-weight: 700;
      font-size: 20px;
      color: var(--text-main);
      margin: 0;
      letter-spacing: -0.02em;
    }

    .site-nav {
      display: flex;
      gap: 24px;
    }

    .site-nav a {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-muted);
    }

    .site-nav a:hover {
      color: var(--accent-primary);
    }

    /* Hero Section */
    .hero-section {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 60px 20px;
      text-align: center;
    }

    .hero-container {
      max-width: 800px;
      margin: 0 auto;
    }

    .hero-title {
      font-family: var(--font-serif);
      font-size: 56px;
      line-height: 1.1;
      margin: 0 0 24px;
      color: var(--text-main);
      letter-spacing: -0.02em;
    }

    .hero-subtitle {
      font-size: 18px;
      line-height: 1.6;
      color: var(--text-muted);
      max-width: 600px;
      margin: 0 auto 48px;
    }

    /* Upload Card */
    .upload-card {
      background: var(--bg-white);
      border-radius: 24px;
      padding: 40px;
      box-shadow: var(--shadow-card);
      border: 1px solid var(--border-soft);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .upload-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
    }

    .drop-zone {
      border: 2px dashed #D6CCC2;
      border-radius: 16px;
      padding: 40px 20px;
      background: #FFFEFC;
      transition: all 0.2s ease;
      cursor: pointer;
      position: relative;
    }

    .drop-zone:hover, .drop-zone.dragover {
      border-color: var(--accent-primary);
      background: var(--accent-soft);
    }

    .drop-zone input[type="file"] {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }

    .drop-icon {
      width: 48px;
      height: 48px;
      color: var(--accent-primary);
      margin-bottom: 16px;
    }

    .drop-hint {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-main);
      margin: 0 0 8px;
    }

    .drop-subhint {
      font-size: 14px;
      color: var(--text-muted);
      margin: 0;
    }

    .status-inline {
      margin-top: 16px;
      font-size: 13px;
      font-weight: 500;
      color: var(--accent-primary);
      min-height: 20px;
    }

    .meta-tags {
      margin-top: 24px;
      display: flex;
      justify-content: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .tag {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      background: #F2EFE9;
      color: var(--text-muted);
      padding: 6px 12px;
      border-radius: 99px;
    }

    /* Features Grid */
    .features-section {
      padding: 80px 20px;
      background: #FFFDFC;
      border-top: 1px solid var(--border-soft);
    }

    .section-container {
      max-width: var(--container-width);
      margin: 0 auto;
    }

    .section-title {
      font-family: var(--font-serif);
      font-size: 32px;
      text-align: center;
      margin: 0 0 60px;
      color: var(--text-main);
    }

    .features-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 32px;
    }

    .feature-item {
      padding: 24px;
      border-radius: 16px;
      background: var(--bg-paper);
      border: 1px solid rgba(0,0,0,0.03);
    }

    .feature-icon {
      width: 24px;
      height: 24px;
      color: var(--accent-primary);
      margin-bottom: 16px;
    }

    .feature-item h3 {
      font-family: var(--font-serif);
      font-size: 20px;
      margin: 0 0 10px;
      color: var(--text-main);
    }

    .feature-item p {
      font-size: 15px;
      color: var(--text-muted);
      margin: 0;
      line-height: 1.6;
    }

    /* How it works */
    .workflow-section {
      padding: 80px 20px;
      background: var(--bg-paper);
    }

    .steps-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 40px;
      counter-reset: step-counter;
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .step-item {
      position: relative;
    }

    .step-item::before {
      counter-increment: step-counter;
      content: "0" counter(step-counter);
      font-family: var(--font-serif);
      font-size: 48px;
      font-weight: 700;
      color: #E8E2D6;
      display: block;
      margin-bottom: 12px;
      line-height: 1;
    }

    .step-item p {
      margin: 0;
      font-size: 15px;
      color: var(--text-muted);
    }

    /* Footer */
    .site-footer {
      padding: 40px 20px;
      text-align: center;
      border-top: 1px solid var(--border-soft);
      background: #FFFDFC;
    }

    .site-footer p {
      font-size: 13px;
      color: var(--text-light);
      margin: 6px 0;
    }

    /* --- Reader Interface (Retained & Polished) --- */
    .layout {
      height: 100vh;
      display: grid;
      grid-template-columns: var(--toc-width) 1fr;
      background: #F3F0E9;
    }

    .side {
      background: #FAF8F5;
      border-right: 1px solid #E6DCCF;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 4px 0 24px rgba(0,0,0,0.02);
      z-index: 10;
    }

    .toc-wrap {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .toc-tree {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    
    .toc-tree .toc-tree {
      margin-left: 12px;
      padding-left: 12px;
      border-left: 1px solid #EFE6D8;
    }

    .toc-tree li {
      margin: 4px 0;
    }

    .toc-tree a {
      display: block;
      padding: 6px 10px;
      font-size: 13px;
      color: #5D554A;
      border-radius: 6px;
      line-height: 1.4;
    }

    .toc-tree a:hover {
      background: #EFE9DE;
      color: #2C2C2C;
    }

    .toc-tree a.active {
      background: #E8DFD0;
      color: #1A1A1A;
      font-weight: 600;
    }
    
    .toc-tree a.disabled {
      color: #B0A89C;
      cursor: default;
    }

    .main {
      background: #FDFBF8;
      overflow-y: auto;
      scroll-behavior: smooth;
      position: relative;
    }

    .content-body {
      max-width: 800px;
      margin: 0 auto;
      padding: 60px 40px 100px;
      background: #FDFBF8;
      min-height: 100%;
    }

    .chapter {
      margin-bottom: 60px;
    }

    .chapter h2 {
      font-family: var(--font-serif);
      font-size: 32px;
      margin-bottom: 24px;
      color: #1A1A1A;
      border-bottom: 1px solid #EFE6D8;
      padding-bottom: 16px;
    }

    .chapter-content {
      font-family: "Georgia", "Times New Roman", serif;
      font-size: 18px;
      line-height: 1.7;
      color: #2C2C2C;
    }

    .chapter-content p {
      margin-bottom: 1.5em;
    }
    
    .chapter-content img {
      max-width: 100%;
      height: auto;
    }

    /* Scrollbars */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    ::-webkit-scrollbar-thumb {
      background: #D8D0C0;
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #C8BFAD;
    }

    /* Mobile */
    @media (max-width: 900px) {
      .hero-title { font-size: 40px; }
      .layout { grid-template-columns: 1fr; }
      .side { display: none; /* Simplification for mobile view if TOC not toggled */ }
      /* Actually original code had layout change. Let's keep a workable simple layout */
      .layout {
         grid-template-columns: 1fr;
         grid-template-rows: auto 1fr;
      }
      .side {
        border-right: none;
        border-bottom: 1px solid #E6DCCF;
        height: 200px;
        display: block;
      }
    }
    @media (max-width: 600px) {
      .site-header { padding: 16px 20px; }
      .hero-section { padding: 40px 20px; }
      .hero-title { font-size: 32px; }
      .upload-card { padding: 24px; }
    }
  </style>
</head>
<body>

  <!-- Landing Screen -->
  <section id="startScreen" class="start-screen">
    <header class="site-header">
      <h1 class="site-brand">epub reader online</h1>
      <nav class="site-nav">
        <a href="#features">Features</a>
        <a href="#how-it-works">How it works</a>
        <a href="#faq">FAQ</a>
      </nav>
    </header>

    <div class="hero-section">
      <div class="hero-container">
        <h1 class="hero-title">Your Personal Library,<br>Reimagined.</h1>
        <p class="hero-subtitle">
          Enjoy a distraction-free reading experience directly in your browser. 
          Upload an EPUB, and we'll handle the rest—parsing, TOC navigation, and continuous scrolling all in memory.
        </p>

        <div class="upload-card">
          <div id="dropZone" class="drop-zone">
            <!-- Icon: Upload Simple -->
            <svg class="drop-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
            </svg>
            <p class="drop-hint">Drop your EPUB file here</p>
            <p class="drop-subhint">or click to browse</p>
            <input id="fileInput" type="file" accept=".epub,application/epub+zip" title="Select EPUB file" />
          </div>
          <div id="statusInline" class="status-inline"></div>
          
          <div class="meta-tags">
             <span class="tag">Local Parsing</span>
             <span class="tag">Private</span>
             <span class="tag">No Signup</span>
          </div>
        </div>
      </div>
    </div>

    <section id="features" class="features-section">
      <div class="section-container">
        <h2 class="section-title">Why this Reader?</h2>
        <div class="features-grid">
          <div class="feature-item">
            <svg class="feature-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
            </svg>
            <h3>Secure & Private</h3>
            <p>Your books never leave your device. All parsing happens locally in your browser memory.</p>
          </div>
          <div class="feature-item">
            <svg class="feature-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16" />
            </svg>
            <h3>Smart TOC</h3>
            <p>We preserve the nested structure of your book, allowing you to view parent and child chapters in one flow.</p>
          </div>
          <div class="feature-item">
            <svg class="feature-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
            <h3>Instant Loading</h3>
            <p>Designed for speed. Drop a file and start reading immediately without server processing.</p>
          </div>
        </div>
      </div>
    </section>

    <footer class="site-footer">
      <p><strong>epub reader online</strong> - Crafted for readers.</p>
      <p>Local-first, privacy-focused, and designed for long-form content.</p>
    </footer>
  </section>

  <!-- Reader Layout (Hidden by default) -->
  <div id="viewerLayout" class="layout" hidden>
    <aside class="side">
      <div id="tocWrap" class="toc-wrap">
        <div class="placeholder" style="padding: 20px; color: #aaa; text-align: center;">Loading Table of Contents...</div>
      </div>
    </aside>

    <section id="mainPanel" class="main" tabindex="0" aria-label="Reader content panel">
      <div id="contentBody" class="content-body">
        <div class="placeholder" style="text-align: center; color: #aaa; padding-top: 40px;">Content will appear here.</div>
      </div>
    </section>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    (function () {
      var fileInput = document.getElementById("fileInput");
      var dropZone = document.getElementById("dropZone");
      var startScreen = document.getElementById("startScreen");
      var viewerLayout = document.getElementById("viewerLayout");
      var tocWrap = document.getElementById("tocWrap");
      var mainPanel = document.getElementById("mainPanel");
      var statusEl = document.getElementById("statusInline");
      var contentBody = document.getElementById("contentBody");
      var isLoading = false;
      var activeTocLink = null;
      var contentSelectMode = false;

      fileInput.addEventListener("change", function (event) {
        var file = event.target.files && event.target.files[0];
        if (file) {
          loadEpub(file);
        }
      });

      dropZone.addEventListener("dragover", function (event) {
        event.preventDefault();
        dropZone.classList.add("dragover");
      });

      dropZone.addEventListener("dragleave", function () {
        dropZone.classList.remove("dragover");
      });

      dropZone.addEventListener("drop", function (event) {
        event.preventDefault();
        dropZone.classList.remove("dragover");
        var file = event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files[0];
        if (file) {
          loadEpub(file);
        }
      });

      document.addEventListener("pointerdown", function (event) {
        if (!viewerLayout || viewerLayout.hidden || !mainPanel) {
          return;
        }
        if (mainPanel.contains(event.target)) {
          contentSelectMode = true;
          if (typeof mainPanel.focus === "function") {
            mainPanel.focus({ preventScroll: true });
          }
        } else {
          contentSelectMode = false;
        }
      });

      document.addEventListener("keydown", function (event) {
        if (!isSelectAllShortcut(event)) {
          return;
        }
        if (!viewerLayout || viewerLayout.hidden || !contentSelectMode) {
          return;
        }
        if (isEditableElement(event.target)) {
          return;
        }
        event.preventDefault();
        selectContentArea(contentBody);
      });

      async function loadEpub(file) {
        if (isLoading) {
          return;
        }

        isLoading = true;
        setLoadingState(true);
        try {
          assertJsZipLoaded();
          setStatus("Reading file...");
          clearRender();

          var buffer = await file.arrayBuffer();
          setStatus("Unzipping EPUB...");
          var zip = await JSZip.loadAsync(buffer);
          var resolver = createResolver(zip);

          setStatus("Parsing container.xml...");
          var opfPath = await locateOpfPath(resolver);
          if (!opfPath) {
            throw new Error("Could not locate the OPF file (missing container.xml or .opf).");
          }

          var opfText = await resolver.readText(opfPath);
          var opfDoc = parseXml(opfText);
          var opfInfo = parseOpf(opfDoc);
          var opfDir = dirname(opfPath);

          var title = opfInfo.title || file.name.replace(/\.epub$/i, "");
          document.title = title + " - EPUB Memory Viewer";

          setStatus("Parsing table of contents (TOC)...");
          var tocData = await parseToc(resolver, opfInfo, opfDir);

          setStatus("Loading chapters...");
          var chapters = await loadSpineChapters(resolver, opfInfo, opfDir, tocData);
          if (chapters.length === 0) {
            throw new Error("No displayable chapters found (empty spine or missing chapter files).");
          }

          setStatus("Rendering page...");
          var sectionMaps = renderChapters(chapters);
          renderToc(tocData, chapters, sectionMaps);

          setStatus(
            "Done: " +
            chapters.length +
            " chapters, TOC source: " +
            humanizeTocSource(tocData.source) +
            ". Click a TOC item to show that node and its children."
          );
          enterViewerMode();
        } catch (error) {
          document.title = "EPUB Memory Viewer";
          setStatus(error && error.message ? error.message : String(error));
          tocWrap.innerHTML = "<div class=\"placeholder\">TOC parsing failed.</div>";
          contentBody.innerHTML = "<div class=\"placeholder\">Content parsing failed. Please check the EPUB structure.</div>";
          if (window.console && window.console.error) {
            window.console.error(error);
          }
          exitViewerMode();
        } finally {
          isLoading = false;
          setLoadingState(false);
        }
      }

      function setLoadingState(flag) {
        fileInput.disabled = !!flag;
        if (flag) {
          dropZone.classList.add("dragover");
        } else {
          dropZone.classList.remove("dragover");
        }
      }

      function enterViewerMode() {
        if (startScreen) {
          startScreen.hidden = true;
        }
        if (viewerLayout) {
          viewerLayout.hidden = false;
        }
        contentSelectMode = true;
      }

      function exitViewerMode() {
        if (viewerLayout) {
          viewerLayout.hidden = true;
        }
        if (startScreen) {
          startScreen.hidden = false;
        }
        contentSelectMode = false;
      }

      function isSelectAllShortcut(event) {
        if (!event) {
          return false;
        }
        var key = (event.key || "").toLowerCase();
        return (event.metaKey || event.ctrlKey) && !event.altKey && key === "a";
      }

      function isEditableElement(target) {
        if (!target || typeof target.closest !== "function") {
          return false;
        }
        return !!target.closest("input, textarea, select, [contenteditable], [contenteditable='plaintext-only']");
      }

      function selectContentArea(container) {
        if (!container || !window.getSelection || !document.createRange) {
          return;
        }
        var selection = window.getSelection();
        if (!selection) {
          return;
        }
        var range = document.createRange();
        range.selectNodeContents(container);
        selection.removeAllRanges();
        selection.addRange(range);
      }

      function assertJsZipLoaded() {
        if (!window.JSZip) {
          throw new Error("JSZip failed to load. Check your network and retry.");
        }
      }

      function setStatus(message) {
        if (statusEl) {
          statusEl.textContent = message;
        }
      }

      function clearRender() {
        tocWrap.innerHTML = "<div class=\"placeholder\">Building table of contents...</div>";
        contentBody.innerHTML = "<div class=\"placeholder\">Building full content...</div>";
      }

      function humanizeTocSource(source) {
        if (source === "ncx") {
          return "toc.ncx";
        }
        if (source === "nav") {
          return "EPUB3 nav";
        }
        return "spine fallback";
      }

      function createResolver(zip) {
        var exact = new Map();
        var lower = new Map();

        Object.keys(zip.files).forEach(function (name) {
          var entry = zip.files[name];
          if (entry.dir) {
            return;
          }
          var norm = normalizePath(name);
          exact.set(norm, name);
          lower.set(norm.toLowerCase(), name);
        });

        return {
          findFirst: function (regex) {
            var found = "";
            exact.forEach(function (_real, path) {
              if (!found && regex.test(path)) {
                found = path;
              }
            });
            return found;
          },
          resolve: function (path) {
            var norm = normalizePath(path);
            var matched = exact.get(norm) || lower.get(norm.toLowerCase()) || "";
            if (matched) {
              return matched;
            }
            var decoded = safeDecode(norm);
            if (decoded !== norm) {
              return exact.get(decoded) || lower.get(decoded.toLowerCase()) || "";
            }
            return "";
          },
          has: function (path) {
            return !!this.resolve(path);
          },
          readText: async function (path) {
            var real = this.resolve(path);
            if (!real) {
              throw new Error("File not found: " + path);
            }
            return zip.file(real).async("string");
          }
        };
      }

      function safeDecode(text) {
        try {
          return decodeURIComponent(text);
        } catch (error) {
          return text;
        }
      }

      async function locateOpfPath(resolver) {
        var containerPath = resolver.resolve("META-INF/container.xml");
        if (containerPath) {
          var containerText = await resolver.readText(containerPath);
          var containerDoc = parseXml(containerText);
          var rootfiles = byLocalName(containerDoc, "rootfile");
          for (var i = 0; i < rootfiles.length; i += 1) {
            var fullPath = rootfiles[i].getAttribute("full-path");
            if (fullPath && resolver.has(fullPath)) {
              return normalizePath(fullPath);
            }
          }
        }

        return resolver.findFirst(/\.opf$/i);
      }

      function parseOpf(opfDoc) {
        var title = "";
        var manifest = new Map();
        var spine = [];
        var spineTocId = "";

        var titleNode = firstByTag(opfDoc, ["dc:title", "title"]);
        if (titleNode) {
          title = cleanText(titleNode.textContent);
        }

        var spineNode = byLocalName(opfDoc, "spine")[0];
        if (spineNode) {
          spineTocId = spineNode.getAttribute("toc") || "";
        }

        var items = byLocalName(opfDoc, "item");
        for (var i = 0; i < items.length; i += 1) {
          var item = items[i];
          if (!item.parentNode || localName(item.parentNode) !== "manifest") {
            continue;
          }
          var id = item.getAttribute("id") || "";
          var href = item.getAttribute("href") || "";
          if (!id || !href) {
            continue;
          }
          manifest.set(id, {
            id: id,
            href: href,
            mediaType: item.getAttribute("media-type") || "",
            properties: item.getAttribute("properties") || ""
          });
        }

        var itemRefs = byLocalName(opfDoc, "itemref");
        for (var j = 0; j < itemRefs.length; j += 1) {
          var itemref = itemRefs[j];
          if (!itemref.parentNode || localName(itemref.parentNode) !== "spine") {
            continue;
          }
          var idref = itemref.getAttribute("idref") || "";
          if (idref) {
            spine.push(idref);
          }
        }

        return {
          title: title,
          manifest: manifest,
          spine: spine,
          spineTocId: spineTocId
        };
      }

      async function parseToc(resolver, opfInfo, opfDir) {
        var manifest = opfInfo.manifest;
        var spineTocId = opfInfo.spineTocId;

        if (spineTocId && manifest.has(spineTocId)) {
          var tocItem = manifest.get(spineTocId);
          var ncxPath = resolveRelative(opfDir, tocItem.href);
          if (resolver.has(ncxPath)) {
            var ncxText = await resolver.readText(ncxPath);
            var ncxDoc = parseXml(ncxText);
            var navMap = byLocalName(ncxDoc, "navMap")[0];
            if (navMap) {
              return {
                source: "ncx",
                baseDir: dirname(ncxPath),
                items: parseNcxPoints(childrenByLocal(navMap, "navPoint"))
              };
            }
          }
        }

        var navItem = null;
        manifest.forEach(function (item) {
          if (navItem) {
            return;
          }
          if ((item.properties || "").split(/\s+/).indexOf("nav") >= 0) {
            navItem = item;
          }
        });

        if (navItem) {
          var navPath = resolveRelative(opfDir, navItem.href);
          if (resolver.has(navPath)) {
            var navText = await resolver.readText(navPath);
            var navDoc = parseXml(navText);
            var navNode = pickTocNavNode(navDoc);
            if (navNode) {
              var rootList = firstChildByLocal(navNode, ["ol", "ul"]) || byLocalName(navNode, "ol")[0] || byLocalName(navNode, "ul")[0];
              if (rootList) {
                return {
                  source: "nav",
                  baseDir: dirname(navPath),
                  items: parseNavList(rootList)
                };
              }
            }
          }
        }

        return {
          source: "spine-fallback",
          baseDir: opfDir,
          items: []
        };
      }

      function parseNcxPoints(nodes) {
        var out = [];
        for (var i = 0; i < nodes.length; i += 1) {
          var navPoint = nodes[i];
          var navLabel = firstChildByLocal(navPoint, ["navLabel"]);
          var textNode = navLabel ? firstChildByLocal(navLabel, ["text"]) : null;
          var contentNode = firstChildByLocal(navPoint, ["content"]);
          out.push({
            title: cleanText(textNode ? textNode.textContent : navLabel ? navLabel.textContent : "Untitled"),
            href: contentNode ? (contentNode.getAttribute("src") || "") : "",
            children: parseNcxPoints(childrenByLocal(navPoint, "navPoint"))
          });
        }
        return out;
      }

      function pickTocNavNode(doc) {
        var navNodes = byLocalName(doc, "nav");
        for (var i = 0; i < navNodes.length; i += 1) {
          var nav = navNodes[i];
          var role = (nav.getAttribute("role") || "").toLowerCase();
          var epubType = (nav.getAttribute("epub:type") || nav.getAttribute("type") || "").toLowerCase();
          if (role === "doc-toc" || epubType.indexOf("toc") >= 0) {
            return nav;
          }
          var attrs = nav.attributes || [];
          for (var k = 0; k < attrs.length; k += 1) {
            if (attrs[k].name && attrs[k].name.toLowerCase().indexOf("type") >= 0 && (attrs[k].value || "").toLowerCase().indexOf("toc") >= 0) {
              return nav;
            }
          }
        }
        return navNodes[0] || null;
      }

      function parseNavList(listNode) {
        var out = [];
        var liNodes = childrenByLocal(listNode, "li");
        for (var i = 0; i < liNodes.length; i += 1) {
          var li = liNodes[i];
          var labelNode = firstChildByLocal(li, ["a", "span", "p", "div"]);
          var listChild = firstChildByLocal(li, ["ol", "ul"]);
          out.push({
            title: cleanText(labelNode ? labelNode.textContent : li.textContent || "Untitled"),
            href: labelNode && localName(labelNode) === "a" ? (labelNode.getAttribute("href") || "") : "",
            children: listChild ? parseNavList(listChild) : []
          });
        }
        return out;
      }

      async function loadSpineChapters(resolver, opfInfo, opfDir, tocData) {
        var manifest = opfInfo.manifest;
        var spine = opfInfo.spine;
        var titleByPath = buildTocTitleMap(tocData.items, tocData.baseDir);
        var chapters = [];

        for (var i = 0; i < spine.length; i += 1) {
          setStatus("Loading chapter " + (i + 1) + " / " + spine.length + " ...");
          var idref = spine[i];
          if (!manifest.has(idref)) {
            continue;
          }
          var item = manifest.get(idref);
          var path = resolveRelative(opfDir, item.href);
          if (!resolver.has(path)) {
            continue;
          }

          var mediaType = (item.mediaType || "").toLowerCase();
          var isHtml = mediaType.indexOf("xhtml") >= 0 || mediaType.indexOf("html") >= 0 || /\.x?html?$/i.test(path);
          if (!isHtml) {
            continue;
          }

          var chapterText = await resolver.readText(path);
          var bodyHtml = extractBodyMarkup(chapterText);
          if (!bodyHtml) {
            continue;
          }

          var heading = titleByPath.get(path) || extractFirstHeading(chapterText) || stripExt(path.split("/").pop() || ("chapter-" + (i + 1)));
          var sectionPrefix = "ch" + (i + 1);
          var prepared = prepareChapterHtml(bodyHtml, sectionPrefix);

          chapters.push({
            index: i + 1,
            path: path,
            title: heading,
            html: prepared.html,
            idMap: prepared.idMap
          });
        }

        return chapters;
      }

      function renderChapters(chapters) {
        contentBody.innerHTML = "";
        var sectionByPath = new Map();
        var idMapByPath = new Map();

        for (var i = 0; i < chapters.length; i += 1) {
          var chapter = chapters[i];
          var sectionId = "section-" + chapter.index;
          var displayTitle = chapter.title || stripExt(chapter.path.split("/").pop() || ("chapter-" + chapter.index));

          var article = document.createElement("article");
          article.className = "chapter";
          article.id = sectionId;

          var h2 = document.createElement("h2");
          h2.textContent = displayTitle;
          article.appendChild(h2);

          var content = document.createElement("div");
          content.className = "chapter-content";
          content.innerHTML = removeDuplicateLeadingHeading(chapter.html, displayTitle);
          article.appendChild(content);

          contentBody.appendChild(article);
          sectionByPath.set(chapter.path, sectionId);
          idMapByPath.set(chapter.path, chapter.idMap);
        }

        return {
          sectionByPath: sectionByPath,
          idMapByPath: idMapByPath
        };
      }

      function renderToc(tocData, chapters, maps) {
        var items = tocData.items && tocData.items.length ? tocData.items : buildSpineFallbackToc(chapters);
        if (!items.length) {
          tocWrap.innerHTML = "<div class=\"placeholder\">No table of contents generated.</div>";
          return;
        }

        activeTocLink = null;
        tocWrap.innerHTML = "";
        var tree = document.createElement("ul");
        tree.className = "toc-tree";
        tocWrap.appendChild(tree);

        var chapterByPath = new Map();
        for (var i = 0; i < chapters.length; i += 1) {
          chapterByPath.set(chapters[i].path, chapters[i]);
        }

        renderTocBranch(items, tree, tocData.baseDir || "", maps.sectionByPath, maps.idMapByPath, chapterByPath);
      }

      function renderTocBranch(items, parentEl, tocBaseDir, sectionByPath, idMapByPath, chapterByPath) {
        for (var i = 0; i < items.length; i += 1) {
          var item = items[i];
          var li = document.createElement("li");
          var row = document.createElement("div");
          row.className = "toc-row";

          var link = document.createElement("a");
          link.textContent = item.title || "Untitled";
          var refs = collectChapterRefsFromItem(item, tocBaseDir, sectionByPath, idMapByPath);
          if (refs.length > 0) {
            link.href = "javascript:void(0)";
            attachTocSelectHandler(link, item, refs, chapterByPath);
          } else {
            link.href = "javascript:void(0)";
            link.classList.add("disabled");
          }

          row.appendChild(link);

          li.appendChild(row);

          if (item.children && item.children.length) {
            var child = document.createElement("ul");
            child.className = "toc-tree";
            li.appendChild(child);
            renderTocBranch(item.children, child, tocBaseDir, sectionByPath, idMapByPath, chapterByPath);
          }

          parentEl.appendChild(li);
        }
      }

      function attachTocSelectHandler(link, item, refs, chapterByPath) {
        link.addEventListener("click", function (event) {
          event.preventDefault();

          if (activeTocLink && activeTocLink !== link) {
            activeTocLink.classList.remove("active");
          }
          activeTocLink = link;
          link.classList.add("active");

          renderSelectedChapters(refs, chapterByPath);
          setStatus("Showing: " + (item.title || "Untitled") + " (" + refs.length + " chapters)");
        });
      }

      function renderSelectedChapters(refs, chapterByPath) {
        contentBody.innerHTML = "";

        var rendered = 0;
        for (var i = 0; i < refs.length; i += 1) {
          var ref = refs[i];
          var chapter = chapterByPath.get(ref.path);
          if (!chapter) {
            continue;
          }
          var displayTitle = ref.title || chapter.title || stripExt(ref.path.split("/").pop() || ref.path);

          var article = document.createElement("article");
          article.className = "chapter";
          article.id = "selected-" + slugify(chapter.path) + "-" + i;

          var h2 = document.createElement("h2");
          h2.textContent = displayTitle;
          article.appendChild(h2);

          var content = document.createElement("div");
          content.className = "chapter-content";
          content.innerHTML = removeDuplicateLeadingHeading(chapter.html, displayTitle);
          article.appendChild(content);

          contentBody.appendChild(article);
          rendered += 1;
        }

        if (!rendered) {
          contentBody.innerHTML = "<div class=\"placeholder\">No displayable chapter content under this node.</div>";
        }

        var mainPanel = contentBody.parentElement;
        if (mainPanel && typeof mainPanel.scrollTo === "function") {
          mainPanel.scrollTo({ top: 0, behavior: "smooth" });
        } else if (mainPanel) {
          mainPanel.scrollTop = 0;
        }
      }

      function collectChapterRefsFromItem(rootItem, tocBaseDir, sectionByPath, idMapByPath) {
        var refs = [];
        var seen = new Set();

        walk(rootItem);
        return refs;

        function walk(node) {
          if (!node) {
            return;
          }

          var ref = resolveTargetRef(tocBaseDir, node.href || "");
          var path = "";

          if (!ref.external) {
            if (ref.path && sectionByPath.has(ref.path)) {
              path = ref.path;
            } else if (!ref.path && ref.fragment) {
              path = findChapterPathByFragment(ref.fragment, idMapByPath);
            }
          }

          if (path && !seen.has(path)) {
            seen.add(path);
            refs.push({
              path: path,
              title: cleanText(node.title || "")
            });
          }

          var children = node.children || [];
          for (var i = 0; i < children.length; i += 1) {
            walk(children[i]);
          }
        }
      }

      function findChapterPathByFragment(fragment, idMapByPath) {
        var matched = "";
        if (!fragment) {
          return matched;
        }
        idMapByPath.forEach(function (idMap, path) {
          if (!matched && idMap && idMap.has(fragment)) {
            matched = path;
          }
        });
        return matched;
      }

      function removeDuplicateLeadingHeading(html, title) {
        var source = html || "";
        if (!source) {
          return "";
        }

        var normalizedTitle = normalizeHeadingCompare(title);
        if (!normalizedTitle) {
          return source;
        }

        var parser = new DOMParser();
        var doc = parser.parseFromString("<!doctype html><html><body>" + source + "</body></html>", "text/html");
        var body = doc.body;
        if (!body) {
          return source;
        }

        var first = body.firstElementChild;
        while (first && isEmptyNode(first)) {
          var next = first.nextElementSibling;
          first.remove();
          first = next;
        }

        if (!first) {
          return body.innerHTML;
        }

        var tag = localName(first);
        if (!/^h[1-6]$/.test(tag)) {
          return body.innerHTML;
        }

        var normalizedFirst = normalizeHeadingCompare(first.textContent || "");
        if (normalizedFirst && normalizedFirst === normalizedTitle) {
          first.remove();
        }

        return body.innerHTML;
      }

      function normalizeHeadingCompare(text) {
        var value = cleanText(text || "").toLowerCase();
        value = value.replace(/["'`“”‘’]+/g, "");
        value = value.replace(/[^a-z0-9\u4e00-\u9fff]+/g, "");
        return value;
      }

      function isEmptyNode(node) {
        if (!node || node.nodeType !== 1) {
          return true;
        }
        if (node.querySelector("img,svg,video,audio,table,ul,ol,blockquote,pre,code")) {
          return false;
        }
        var txt = (node.textContent || "").replace(/\u00a0/g, "").trim();
        return txt.length === 0;
      }

      function isEmptyBlock(node) {
        if (!node || node.nodeType !== 1) {
          return false;
        }
        var tag = localName(node);
        var allowed = ["p", "div", "span"];
        if (allowed.indexOf(tag) < 0) {
          return false;
        }
        if (node.querySelector("img,svg,video,audio,table,ul,ol,blockquote,pre,code")) {
          return false;
        }
        var txt = (node.textContent || "").replace(/\u00a0/g, "").trim();
        return txt.length === 0;
      }

      function resolveTargetRef(baseDir, href) {
        var raw = (href || "").trim();
        var hashIdx = raw.indexOf("#");
        var pathPart = hashIdx >= 0 ? raw.slice(0, hashIdx) : raw;
        var frag = hashIdx >= 0 ? decodeURIComponent(raw.slice(hashIdx + 1)) : "";

        if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(pathPart)) {
          return { external: true, path: pathPart, fragment: frag };
        }

        if (!pathPart) {
          return { external: false, path: "", fragment: frag };
        }

        return {
          external: false,
          path: resolveRelative(baseDir, pathPart),
          fragment: frag
        };
      }

      function resolveRelative(baseDir, hrefPath) {
        if (!hrefPath) {
          return normalizePath(baseDir || "");
        }
        if (hrefPath.indexOf("/") === 0) {
          return normalizePath(hrefPath.slice(1));
        }
        var base = baseDir ? baseDir + "/" : "";
        return normalizePath(base + hrefPath);
      }

      function dirname(path) {
        var norm = normalizePath(path);
        var idx = norm.lastIndexOf("/");
        return idx < 0 ? "" : norm.slice(0, idx);
      }

      function normalizePath(path) {
        var input = (path || "").replace(/\\/g, "/");
        var parts = input.split("/");
        var out = [];
        for (var i = 0; i < parts.length; i += 1) {
          var p = parts[i];
          if (!p || p === ".") {
            continue;
          }
          if (p === "..") {
            out.pop();
            continue;
          }
          out.push(p);
        }
        return out.join("/");
      }

      function parseXml(text) {
        var parser = new DOMParser();
        var xmlDoc = parser.parseFromString(text, "application/xml");
        if (!hasParserError(xmlDoc)) {
          return xmlDoc;
        }
        return parser.parseFromString(text, "text/html");
      }

      function hasParserError(doc) {
        return byLocalName(doc, "parsererror").length > 0;
      }

      function getBodyFromDoc(doc) {
        if (!doc) {
          return null;
        }
        if (doc.body) {
          return doc.body;
        }
        var bodyNodes = byLocalName(doc, "body");
        return bodyNodes[0] || null;
      }

      function getInnerMarkup(node) {
        if (!node) {
          return "";
        }
        if (typeof node.innerHTML === "string") {
          return node.innerHTML;
        }
        var serializer = new XMLSerializer();
        var out = "";
        for (var i = 0; i < node.childNodes.length; i += 1) {
          out += serializer.serializeToString(node.childNodes[i]);
        }
        return out;
      }

      function byLocalName(root, name) {
        if (!root || !name) {
          return [];
        }

        var result = [];
        var seen = new Set();

        var list1 = root.getElementsByTagName ? root.getElementsByTagName(name) : [];
        for (var i = 0; i < list1.length; i += 1) {
          if (!seen.has(list1[i])) {
            seen.add(list1[i]);
            result.push(list1[i]);
          }
        }

        if (root.getElementsByTagNameNS) {
          var list2 = root.getElementsByTagNameNS("*", name);
          for (var j = 0; j < list2.length; j += 1) {
            if (!seen.has(list2[j])) {
              seen.add(list2[j]);
              result.push(list2[j]);
            }
          }
        }

        return result;
      }

      function childrenByLocal(node, name) {
        if (!node || !node.childNodes) {
          return [];
        }
        var target = String(name || "").toLowerCase();
        var out = [];
        for (var i = 0; i < node.childNodes.length; i += 1) {
          var child = node.childNodes[i];
          if (child.nodeType !== 1) {
            continue;
          }
          if (localName(child) === target) {
            out.push(child);
          }
        }
        return out;
      }

      function firstChildByLocal(node, names) {
        if (!node || !node.childNodes) {
          return null;
        }
        var targets = (names || []).map(function (n) { return String(n).toLowerCase(); });
        for (var i = 0; i < node.childNodes.length; i += 1) {
          var child = node.childNodes[i];
          if (child.nodeType !== 1) {
            continue;
          }
          if (targets.indexOf(localName(child)) >= 0) {
            return child;
          }
        }
        return null;
      }

      function firstByTag(root, names) {
        for (var i = 0; i < names.length; i += 1) {
          var list = root.getElementsByTagName(names[i]);
          if (list && list.length) {
            return list[0];
          }
        }
        for (var j = 0; j < names.length; j += 1) {
          var local = names[j].indexOf(":") >= 0 ? names[j].split(":")[1] : names[j];
          var listNs = byLocalName(root, local);
          if (listNs.length) {
            return listNs[0];
          }
        }
        return null;
      }

      function localName(node) {
        return (node.localName || node.nodeName || "").toLowerCase().replace(/^.*:/, "");
      }

      function cleanText(text) {
        return (text || "").replace(/\s+/g, " ").trim();
      }

      function slugify(text) {
        var s = (text || "").toLowerCase().replace(/[^a-z0-9_\-:.]+/g, "-").replace(/^-+|-+$/g, "");
        return s || "id";
      }

      function stripExt(name) {
        return name.replace(/\.[^.]+$/, "");
      }
      function buildSpineFallbackToc(chapters) {
        return chapters.map(function (chapter) {
          return {
            title: chapter.title,
            href: chapter.path,
            children: []
          };
        });
      }

      function buildTocTitleMap(items, baseDir) {
        var map = new Map();
        walkToc(items, function (item) {
          if (!item.href) {
            return;
          }
          var ref = resolveTargetRef(baseDir, item.href);
          if (ref.path && !map.has(ref.path)) {
            map.set(ref.path, item.title || "");
          }
        });
        return map;
      }

      function walkToc(items, visit) {
        for (var i = 0; i < items.length; i += 1) {
          visit(items[i]);
          if (items[i].children && items[i].children.length) {
            walkToc(items[i].children, visit);
          }
        }
      }

      function extractBodyMarkup(raw) {
        var doc = parseXml(raw);
        var body = getBodyFromDoc(doc);
        if (body) {
          return getInnerMarkup(body);
        }
        var fallback = raw.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
        return fallback ? fallback[1] : "";
      }

      function extractFirstHeading(raw) {
        var doc = parseXml(raw);
        var body = getBodyFromDoc(doc) || doc;
        var tags = ["h1", "h2", "h3", "h4", "h5", "h6"];
        for (var i = 0; i < tags.length; i += 1) {
          var nodes = byLocalName(body, tags[i]);
          if (nodes.length) {
            var txt = cleanText(nodes[0].textContent);
            if (txt) {
              return txt;
            }
          }
        }
        return "";
      }

      function prepareChapterHtml(rawHtml, prefix) {
        var parser = new DOMParser();
        var doc = parser.parseFromString("<!DOCTYPE html><html><body><div id=\"root\"></div></body></html>", "text/html");
        var root = doc.getElementById("root");
        root.innerHTML = rawHtml;

        var removeSelector = "script,style,meta,base,link[rel='stylesheet'],iframe,object,embed";
        var removeNodes = root.querySelectorAll(removeSelector);
        for (var i = 0; i < removeNodes.length; i += 1) {
          removeNodes[i].remove();
        }

        var idMap = new Map();
        var idNodes = root.querySelectorAll("[id]");
        for (var j = 0; j < idNodes.length; j += 1) {
          var oldId = idNodes[j].getAttribute("id") || "";
          if (!oldId) {
            continue;
          }
          var newId = prefix + "__" + slugify(oldId) + "__" + j;
          idMap.set(oldId, newId);
          idNodes[j].setAttribute("id", newId);
        }

        var hashLinks = root.querySelectorAll("a[href^='#']");
        for (var k = 0; k < hashLinks.length; k += 1) {
          var href = hashLinks[k].getAttribute("href") || "";
          var key = href.replace(/^#/, "");
          if (idMap.has(key)) {
            hashLinks[k].setAttribute("href", "#" + idMap.get(key));
          }
        }

        trimEmptyEdges(root, 12);

        return {
          html: root.innerHTML,
          idMap: idMap
        };
      }

      function trimEmptyEdges(root, maxCount) {
        var count = 0;
        while (root.firstElementChild && count < maxCount && isEmptyBlock(root.firstElementChild)) {
          root.firstElementChild.remove();
          count += 1;
        }
        count = 0;
        while (root.lastElementChild && count < maxCount && isEmptyBlock(root.lastElementChild)) {
          root.lastElementChild.remove();
          count += 1;
        }
      }
    })();
  </script>
</body>
</html>
