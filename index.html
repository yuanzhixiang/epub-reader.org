<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>epub reader online - In-Browser EPUB Reader with TOC and Full Chapter View</title>
  <meta name="description" content="epub reader online is an in-browser EPUB reader. Upload an EPUB file, parse OPF + TOC + spine in memory, navigate nested TOC nodes, and read full node-plus-children content in one continuous view." />
  <meta name="robots" content="index,follow" />
  <meta property="og:title" content="epub reader online" />
  <meta property="og:description" content="A local-first epub reader online experience that parses EPUB files in memory and renders nested TOC content in a continuous reading layout." />
  <meta property="og:type" content="website" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lato:ital,wght@0,400;0,700;1,400&family=Playfair+Display:ital,wght@0,400;0,600;0,700;1,400&display=swap" rel="stylesheet">
  
  <script defer data-domain="epub-reader.org" src="https://plausible.yuanzhixiang.com/js/script.js"></script>
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "SoftwareApplication",
      "name": "epub reader online",
      "applicationCategory": "BrowserApplication",
      "operatingSystem": "Any",
      "description": "epub reader online is an in-browser tool that parses OPF, TOC, and spine, then renders full chapter content in a continuous view.",
      "featureList": [
        "Local in-memory EPUB parsing",
        "Nested TOC rendering",
        "Node and descendant chapter display",
        "Single-page continuous reading"
      ]
    }
  </script>

  <style>
    :root {
      /* Palette */
      --bg-paper: #F9F7F2;
      --bg-white: #FFFFFF;
      --text-main: #2C2C2C;
      --text-muted: #666055;
      --text-light: #8E867A;
      --accent-primary: #C07248;
      --accent-hover: #A65D35;
      --accent-soft: #F4EBE6;
      --border-soft: #EBE5DA;
      --shadow-card: 0 12px 32px rgba(40, 30, 20, 0.06);
      --shadow-hover: 0 16px 48px rgba(40, 30, 20, 0.1);
      
      /* Layout */
      --container-width: 800px;
      --toc-width: 320px;
      
      /* Typography */
      --font-serif: "Playfair Display", serif;
      --font-sans: "Lato", "IBM Plex Sans", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background-color: var(--bg-paper);
      color: var(--text-main);
      font-family: var(--font-sans);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    [hidden] {
      display: none !important;
    }

    a {
      color: inherit;
      text-decoration: none;
      transition: color 0.2s ease;
    }

    /* --- Start Screen / Landing Page --- */
    .start-screen {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    .site-header {
      padding: 20px 40px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-width: var(--container-width);
      margin: 0 auto;
      width: 100%;
    }

    .site-brand {
      font-family: var(--font-serif);
      font-weight: 700;
      font-size: 20px;
      color: var(--text-main);
      margin: 0;
      letter-spacing: -0.02em;
    }

    .site-nav {
      display: flex;
      gap: 24px;
    }

    .site-nav a {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-muted);
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .site-nav a:hover {
      color: var(--accent-primary);
    }


    /* Hero Section */
    .hero-section {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 80px 20px;
      text-align: center;
    }

    .hero-container {
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
    }

    .hero-title {
      font-family: var(--font-serif);
      font-size: 56px;
      line-height: 1.1;
      margin: 0 0 24px;
      color: var(--text-main);
      letter-spacing: -0.02em;
    }

    .hero-subtitle {
     font-family: var(--font-sans);
      font-size: 18px;
      line-height: 1.8; /* Increased line height for better readability */
      color: var(--text-muted);
      max-width: 680px; /* Slightly wider */
      margin: 0 auto 48px;
      font-weight: 400;
    }

    /* Section Typography & Spacing Improvements */
    .features-section, .workflow-section {
      padding: 100px 20px; /* More breathing room */
    }

    .section-container {
      width: 100%;
      max-width: var(--container-width);
      margin: 0 auto;
    }

    .section-title {
      font-family: var(--font-serif);
      font-size: 36px; /* Larger headings */
      text-align: center;
      margin: 0 0 60px;
      color: var(--text-main);
    }

    .description-text {
      max-width: 800px; 
      margin: 0 auto 60px; 
      text-align: center; 
      font-size: 18px; /* Larger body text */
      line-height: 1.8; 
      color: var(--text-muted);
    }

    /* Upload Card */
    .upload-card {
      width: 100%;
      background: var(--bg-white);
      border-radius: 24px;
      padding: 40px;
      box-shadow: var(--shadow-card);
      border: 1px solid var(--border-soft);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    
    .upload-card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
    }

    .drop-zone {
      border: 2px dashed #D6CCC2;
      border-radius: 16px;
      min-height: 250px;
      padding: 40px 20px;
      background: #FFFEFC;
      transition: all 0.2s ease;
      cursor: pointer;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .drop-zone:hover, .drop-zone.dragover {
      border-color: var(--accent-primary);
      background: var(--accent-soft);
    }

    .drop-zone input[type="file"] {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }

    .drop-icon {
      width: 48px;
      height: 48px;
      color: var(--accent-primary);
      margin-bottom: 24px;
    }
    
    .feature-icon {
      width: 24px;
      height: 24px;
      color: var(--accent-primary);
      margin-bottom: 16px;
      flex-shrink: 0;
    }

    .drop-hint {
      font-size: 20px; /* Highlight drop text */
      font-weight: 600;
      color: var(--text-main);
      margin: 0 0 12px;
      line-height: 1.4;
    }

    /* Features Grid */
    .features-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 32px;
    }

    @media (max-width: 768px) {
      .features-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Feature Grid Improvements */
    .feature-item {
      padding: 32px; /* More internal padding */
      border-radius: 16px;
      background: var(--bg-paper);
      border: 1px solid rgba(0,0,0,0.04);
      height: 100%;
    }

    .feature-item h3 {
      font-family: var(--font-serif);
      font-size: 22px;
      margin: 0 0 12px;
      color: var(--text-main);
    }

    .feature-item p {
      font-size: 16px;
      color: var(--text-muted);
      margin: 0;
      line-height: 1.7; /* Comfortable reading */
    }

    /* Workflow Steps */
    .steps-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 40px;
      counter-reset: step-counter;
      list-style: none;
      padding: 0;
      margin: 0;
      max-width: 100%;
      margin-inline: auto;
    }
    
    .step-item p {
       font-size: 16px;
       line-height: 1.7;
       color: var(--text-muted);
    }

    /* FAQ List Layout using Grid */
    .faq-grid {
       max-width: 800px;
       margin: 0 auto;
       display: grid;
       gap: 24px;
    }
    
    .faq-item {
       padding: 24px;
       background: var(--bg-white);
       border-radius: 12px;
       border: 1px solid var(--border-soft);
    }
    
    .faq-item p {
       margin: 0;
       font-size: 16px;
       line-height: 1.7;
       color: var(--text-muted);
    }
    
    .faq-item strong {
       color: var(--text-main);
       display: block;
       margin-bottom: 8px;
       font-family: var(--font-serif);
       font-size: 18px;
    }
    
    /* Footer */
    .site-footer {
      padding: 60px 20px;
      text-align: center;
      border-top: 1px solid var(--border-soft);
      background: #FFFDFC;
    }

    .site-footer p {
      font-size: 14px;
      color: var(--text-light);
      margin: 8px 0;
      line-height: 1.6;
    }

    /* --- Reader Interface (Retained & Polished) --- */
    .layout {
      height: 100vh;
      display: grid;
      grid-template-columns: var(--toc-width) 1fr;
      background: #F3F0E9;
    }

    .side {
      background: #FAF8F5;
      border-right: 1px solid #E6DCCF;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      box-shadow: 4px 0 24px rgba(0,0,0,0.02);
      z-index: 10;
    }

    .toc-wrap {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .toc-tree {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    
    .toc-tree .toc-tree {
      margin-left: 12px;
      padding-left: 12px;
      border-left: 1px solid #EFE6D8;
    }

    .toc-tree li {
      margin: 4px 0;
    }

    .toc-tree a {
      display: block;
      padding: 6px 10px;
      font-size: 13px;
      color: #5D554A;
      border-radius: 6px;
      line-height: 1.4;
    }

    .toc-tree a:hover {
      background: #EFE9DE;
      color: #2C2C2C;
    }

    .toc-tree a.active {
      background: #E8DFD0;
      color: #1A1A1A;
      font-weight: 600;
    }
    
    .toc-tree a.disabled {
      color: #B0A89C;
      cursor: default;
    }

    .main {
      background: #FDFBF8;
      overflow-y: auto;
      scroll-behavior: smooth;
      position: relative;
    }

    .content-body {
      max-width: 800px;
      margin: 0 auto;
      padding: 60px 40px 100px;
      background: #FDFBF8;
      min-height: 100%;
    }

    .chapter {
      margin-bottom: 60px;
    }

    .chapter h2 {
      font-family: var(--font-serif);
      font-size: 32px;
      margin-bottom: 24px;
      color: #1A1A1A;
      border-bottom: 1px solid #EFE6D8;
      padding-bottom: 16px;
    }

    .chapter-content {
      font-family: "Georgia", "Times New Roman", serif;
      font-size: 18px;
      line-height: 1.7;
      color: #2C2C2C;
    }

    .chapter-content p {
      margin-bottom: 1.5em;
    }
    
    .chapter-content img {
      max-width: 100%;
      height: auto;
    }

    /* Scrollbars */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: transparent;
    }
    ::-webkit-scrollbar-thumb {
      background: #D8D0C0;
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #C8BFAD;
    }

    /* Mobile */
    @media (max-width: 900px) {
      .hero-title { font-size: 40px; }
      .layout { grid-template-columns: 1fr; }
      .side { display: none; /* Simplification for mobile view if TOC not toggled */ }
      /* Actually original code had layout change. Let's keep a workable simple layout */
      .layout {
         grid-template-columns: 1fr;
         grid-template-rows: auto 1fr;
      }
      .side {
        border-right: none;
        border-bottom: 1px solid #E6DCCF;
        height: 200px;
        display: block;
      }
    }
    @media (max-width: 600px) {
      .site-header { padding: 16px 20px; }
      .hero-section { padding: 40px 20px; }
      .hero-title { font-size: 32px; }
      .upload-card { padding: 24px; }
      .drop-zone {
        min-height: 200px;
        padding: 32px 18px;
      }
    }
  </style>
</head>
<body>

  <!-- Landing Screen -->
  <section id="startScreen" class="start-screen">
    <header class="site-header">
      <h1 class="site-brand">epub reader online</h1>
      <nav class="site-nav">
        <a href="#features">Features</a>
        <a href="#workflow">How it works</a>
        <a href="#faq">FAQ</a>
        <a href="https://github.com/yuanzhixiang/epub-reader.org" target="_blank" rel="noopener noreferrer" class="nav-github">
           <svg height="20" width="20" viewBox="0 0 16 16" fill="currentColor">
              <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
           </svg>
           GitHub
         </a>
      </nav>
    </header>

    <div class="hero-section">
      <div class="hero-container">
        <h1 class="hero-title">epub reader</h1>
        <p class="hero-subtitle">
          Upload one EPUB file and start reading instantly in your browser.
        </p>

        <div class="upload-card">
          <div id="dropZone" class="drop-zone">
            <!-- Icon: Upload Simple -->
            <svg class="drop-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
            </svg>
            <p class="drop-hint">Drag and drop an EPUB file here to begin.</p>
            <input id="fileInput" type="file" accept=".epub,application/epub+zip" title="Select EPUB file" />
          </div>
          <p id="statusInline" class="status-inline" style="text-align: center; color: var(--accent-primary); font-weight: 500; padding-top: 20px;">Choose an .epub file to begin.</p>
        </div>
      </div>
    </div>

    <!-- Restored Original Sections with New Design -->
    <section id="features" class="features-section">
      <div class="section-container">
        <!-- Overview Section -->
        <h2 class="section-title">What This epub reader Does</h2>
        <div class="description-text">
          <p>This epub reader turns a raw EPUB package into a practical reading workspace. The app resolves package metadata, spine order, and TOC hierarchy, then presents chapter content in a clean continuous flow while keeping the processing inside your browser session. For teams that search for an epub reader online, this page explains a local-first browser model with no account friction and no server pipeline dependency.</p>
        </div>

        <h2 class="section-title">Core Features</h2>
        <div class="features-grid">
          <div class="feature-item">
            <svg class="feature-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
            </svg>
            <h3>In-Browser Parsing</h3>
            <p>This epub reader processes files locally in memory, with no server-side upload pipeline required.</p>
          </div>
          <div class="feature-item">
            <svg class="feature-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 10h16M4 14h16M4 18h16" />
            </svg>
            <h3>TOC-Aware Navigation</h3>
            <p>The reader preserves nested TOC structure from NCX or EPUB3 nav documents in the left sidebar.</p>
          </div>
          <div class="feature-item">
            <svg class="feature-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
            <h3>Node + Children Reading</h3>
            <p>Clicking a TOC node tells the epub reader to show that node and all descendants in one content stream.</p>
          </div>
          <div class="feature-item">
             <svg class="feature-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z" />
            </svg>
            <h3>Reader-Friendly Selection</h3>
            <p>Inside the content pane, this reader supports Cmd/Ctrl + A to select only reader content.</p>
          </div>
        </div>
      </div>
    </section>

    <!-- Workflow Section -->
    <section id="workflow" class="workflow-section">
      <div class="section-container">
        <h2 class="section-title">How This epub reader Works</h2>
        <div class="steps-list">
          <div class="step-item">
             <p>Upload one EPUB file to the app.</p>
          </div>
          <div class="step-item">
             <p>The app resolves <code>container.xml</code>, finds OPF, and parses manifest + spine entries.</p>
          </div>
          <div class="step-item">
             <p>It builds TOC data from NCX or EPUB3 nav, with spine fallback when needed.</p>
          </div>
          <div class="step-item">
             <p>Chapter bodies are normalized and rendered into a single scrollable reading surface.</p>
          </div>
          <div class="step-item">
             <p>Click any TOC node to focus reading on that section and all child sections.</p>
          </div>
        </div>
      </div>
    </section>

    <!-- Additional Content Sections (Audience, Privacy) -->
    <section id="audience" class="features-section" style="background: #F9F7F2;">
       <div class="section-container">
          <div class="features-grid">
             <div class="feature-item" style="background: white;">
                <h3>Who Uses This epub reader</h3>
                <p>This epub reader is useful for researchers, editors, analysts, and students who need a fast way to inspect and navigate full EPUB content. Because it can show a parent node with all children in one view, it is practical for summarization, auditing, and structured review tasks. Many users discover this tool while searching for an epub reader online that keeps context and hierarchy visible in one place.</p>
             </div>
             <div class="feature-item" style="background: white;">
                <h3>Privacy and Local Workflow</h3>
                <p>By design, this reader handles files in browser memory during the session. That local-first approach is helpful when you want quick EPUB inspection without external storage pipelines, and it keeps the reading workflow close to your local environment. Even as an epub reader online experience, the runtime model stays browser-local for day-to-day reading tasks.</p>
             </div>
          </div>
       </div>
    </section>

    <!-- FAQ Section -->
    <section id="faq" class="features-section">
       <div class="section-container">
          <h2 class="section-title">FAQ</h2>
          <div class="faq-grid">
             <div class="faq-item">
                <p><strong>Can this epub reader open nested chapter structures?</strong> Yes. It reads NCX or EPUB3 nav and preserves hierarchy.</p>
             </div>
             <div class="faq-item">
                <p><strong>Can this epub reader show one section plus all descendants?</strong> Yes. Click one TOC node to render the full node-plus-children range.</p>
             </div>
             <div class="faq-item">
                <p><strong>Does this epub reader require account login?</strong> No. You can run it directly in a browser session.</p>
             </div>
             <div class="faq-item">
                <p><strong>Can I use this reader for large books?</strong> Yes. It was designed for long-form reading and structured navigation.</p>
             </div>
             <div class="faq-item">
                 <p><strong>Is this an epub reader online workflow?</strong> Yes. It runs in your browser, and the parsing flow starts as soon as you load one file.</p>
             </div>
          </div>
       </div>
    </section>

    <!-- Start Section -->
    <section id="start" class="hero-section" style="min-height: auto; padding-top: 0;">
       <div class="hero-container">
          <h2 class="section-title" style="margin-bottom: 24px;">Start Reading</h2>
          <p class="hero-subtitle">
            Drop your file in the box above and let this epub reader build the full reading surface. If your goal is faster navigation, cleaner section review, and one continuous output stream, this tool is ready to use now. If your search query was epub reader online, you are in the right place to test a full browser flow immediately.
          </p>
       </div>
    </section>

    <footer class="site-footer">
      <p><strong>epub reader online</strong> for structured, long-form reading in one browser session.</p>
      <p>This landing page and reader are designed for practical EPUB navigation, TOC-aware section review, and continuous chapter rendering without server-side document pipelines.</p>
      <div style="margin-top: 24px; display: flex; flex-direction: column; gap: 8px; align-items: center;">

         <p style="margin: 0;">Contact us: <a href="mailto:support@epub-reader.org" style="color: var(--accent-primary); font-weight: 500;">support@epub-reader.org</a></p>
      </div>
    </footer>
  </section>

  <!-- Reader Layout (Hidden by default) -->
  <div id="viewerLayout" class="layout" hidden>
    <aside class="side">
      <div id="tocWrap" class="toc-wrap">
        <div class="placeholder" style="padding: 20px; color: #aaa; text-align: center;">Loading Table of Contents...</div>
      </div>
    </aside>

    <section id="mainPanel" class="main" tabindex="0" aria-label="Reader content panel">
      <div id="contentBody" class="content-body">
        <div class="placeholder" style="text-align: center; color: #aaa; padding-top: 40px;">Content will appear here.</div>
      </div>
    </section>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script>
    (function () {
      var fileInput = document.getElementById("fileInput");
      var dropZone = document.getElementById("dropZone");
      var startScreen = document.getElementById("startScreen");
      var viewerLayout = document.getElementById("viewerLayout");
      var tocWrap = document.getElementById("tocWrap");
      var mainPanel = document.getElementById("mainPanel");
      var statusEl = document.getElementById("statusInline");
      var contentBody = document.getElementById("contentBody");
      var isLoading = false;
      var activeTocLink = null;
      var contentSelectMode = false;
      var mediaAssetUrlCache = new Map();
      var mediaAssetObjectUrls = [];

      fileInput.addEventListener("change", function (event) {
        var file = event.target.files && event.target.files[0];
        if (file) {
          loadEpub(file);
        }
      });

      dropZone.addEventListener("dragover", function (event) {
        event.preventDefault();
        dropZone.classList.add("dragover");
      });

      dropZone.addEventListener("dragleave", function () {
        dropZone.classList.remove("dragover");
      });

      dropZone.addEventListener("drop", function (event) {
        event.preventDefault();
        dropZone.classList.remove("dragover");
        var file = event.dataTransfer && event.dataTransfer.files && event.dataTransfer.files[0];
        if (file) {
          loadEpub(file);
        }
      });

      document.addEventListener("pointerdown", function (event) {
        if (!viewerLayout || viewerLayout.hidden || !mainPanel) {
          return;
        }
        if (mainPanel.contains(event.target)) {
          contentSelectMode = true;
          if (typeof mainPanel.focus === "function") {
            mainPanel.focus({ preventScroll: true });
          }
        } else {
          contentSelectMode = false;
        }
      });

      document.addEventListener("keydown", function (event) {
        if (!isSelectAllShortcut(event)) {
          return;
        }
        if (!viewerLayout || viewerLayout.hidden || !contentSelectMode) {
          return;
        }
        if (isEditableElement(event.target)) {
          return;
        }
        event.preventDefault();
        selectContentArea(contentBody);
      });

      async function loadEpub(file) {
        if (isLoading) {
          return;
        }

        isLoading = true;
        setLoadingState(true);
        try {
          assertJsZipLoaded();
          setStatus("Reading file...");
          revokeMediaAssetUrls();
          clearRender();

          var buffer = await file.arrayBuffer();
          setStatus("Unzipping EPUB...");
          var zip = await JSZip.loadAsync(buffer);
          var resolver = createResolver(zip);

          setStatus("Parsing container.xml...");
          var opfPath = await locateOpfPath(resolver);
          if (!opfPath) {
            throw new Error("Could not locate the OPF file (missing container.xml or .opf).");
          }

          var opfText = await resolver.readText(opfPath);
          var opfDoc = parseXml(opfText);
          var opfInfo = parseOpf(opfDoc);
          var opfDir = dirname(opfPath);

          var title = opfInfo.title || file.name.replace(/\.epub$/i, "");
          document.title = title + " - EPUB Memory Viewer";

          setStatus("Parsing table of contents (TOC)...");
          var tocData = await parseToc(resolver, opfInfo, opfDir);

          setStatus("Loading chapters...");
          var chapters = await loadSpineChapters(resolver, opfInfo, opfDir, tocData);
          if (chapters.length === 0) {
            throw new Error("No displayable chapters found (empty spine or missing chapter files).");
          }

          setStatus("Rendering page...");
          var sectionMaps = renderChapters(chapters);
          renderToc(tocData, chapters, sectionMaps);

          setStatus(
            "Done: " +
            chapters.length +
            " chapters, TOC source: " +
            humanizeTocSource(tocData.source) +
            ". Click a TOC item to show that node and its children."
          );
          enterViewerMode();
        } catch (error) {
          revokeMediaAssetUrls();
          document.title = "EPUB Memory Viewer";
          setStatus(error && error.message ? error.message : String(error));
          tocWrap.innerHTML = "<div class=\"placeholder\">TOC parsing failed.</div>";
          contentBody.innerHTML = "<div class=\"placeholder\">Content parsing failed. Please check the EPUB structure.</div>";
          if (window.console && window.console.error) {
            window.console.error(error);
          }
          exitViewerMode();
        } finally {
          isLoading = false;
          setLoadingState(false);
        }
      }

      function setLoadingState(flag) {
        fileInput.disabled = !!flag;
        if (flag) {
          dropZone.classList.add("dragover");
        } else {
          dropZone.classList.remove("dragover");
        }
      }

      function enterViewerMode() {
        if (startScreen) {
          startScreen.hidden = true;
        }
        if (viewerLayout) {
          viewerLayout.hidden = false;
        }
        contentSelectMode = true;
      }

      function exitViewerMode() {
        if (viewerLayout) {
          viewerLayout.hidden = true;
        }
        if (startScreen) {
          startScreen.hidden = false;
        }
        contentSelectMode = false;
      }

      function isSelectAllShortcut(event) {
        if (!event) {
          return false;
        }
        var key = (event.key || "").toLowerCase();
        return (event.metaKey || event.ctrlKey) && !event.altKey && key === "a";
      }

      function isEditableElement(target) {
        if (!target || typeof target.closest !== "function") {
          return false;
        }
        return !!target.closest("input, textarea, select, [contenteditable], [contenteditable='plaintext-only']");
      }

      function selectContentArea(container) {
        if (!container || !window.getSelection || !document.createRange) {
          return;
        }
        var selection = window.getSelection();
        if (!selection) {
          return;
        }
        var range = document.createRange();
        range.selectNodeContents(container);
        selection.removeAllRanges();
        selection.addRange(range);
      }

      function assertJsZipLoaded() {
        if (!window.JSZip) {
          throw new Error("JSZip failed to load. Check your network and retry.");
        }
      }

      function setStatus(message) {
        if (statusEl) {
          statusEl.textContent = message;
        }
      }

      function clearRender() {
        tocWrap.innerHTML = "<div class=\"placeholder\">Building table of contents...</div>";
        contentBody.innerHTML = "<div class=\"placeholder\">Building full content...</div>";
      }

      function humanizeTocSource(source) {
        if (source === "ncx") {
          return "toc.ncx";
        }
        if (source === "nav") {
          return "EPUB3 nav";
        }
        return "spine fallback";
      }

      function createResolver(zip) {
        var exact = new Map();
        var lower = new Map();

        Object.keys(zip.files).forEach(function (name) {
          var entry = zip.files[name];
          if (entry.dir) {
            return;
          }
          var norm = normalizePath(name);
          exact.set(norm, name);
          lower.set(norm.toLowerCase(), name);
        });

        return {
          findFirst: function (regex) {
            var found = "";
            exact.forEach(function (_real, path) {
              if (!found && regex.test(path)) {
                found = path;
              }
            });
            return found;
          },
          resolve: function (path) {
            var norm = normalizePath(path);
            var matched = exact.get(norm) || lower.get(norm.toLowerCase()) || "";
            if (matched) {
              return matched;
            }
            var decoded = safeDecode(norm);
            if (decoded !== norm) {
              return exact.get(decoded) || lower.get(decoded.toLowerCase()) || "";
            }
            return "";
          },
          has: function (path) {
            return !!this.resolve(path);
          },
          readText: async function (path) {
            var real = this.resolve(path);
            if (!real) {
              throw new Error("File not found: " + path);
            }
            return zip.file(real).async("string");
          },
          readBinary: async function (path) {
            var real = this.resolve(path);
            if (!real) {
              throw new Error("File not found: " + path);
            }
            return zip.file(real).async("uint8array");
          }
        };
      }

      function safeDecode(text) {
        try {
          return decodeURIComponent(text);
        } catch (error) {
          return text;
        }
      }

      async function locateOpfPath(resolver) {
        var containerPath = resolver.resolve("META-INF/container.xml");
        if (containerPath) {
          var containerText = await resolver.readText(containerPath);
          var containerDoc = parseXml(containerText);
          var rootfiles = byLocalName(containerDoc, "rootfile");
          for (var i = 0; i < rootfiles.length; i += 1) {
            var fullPath = rootfiles[i].getAttribute("full-path");
            if (fullPath && resolver.has(fullPath)) {
              return normalizePath(fullPath);
            }
          }
        }

        return resolver.findFirst(/\.opf$/i);
      }

      function parseOpf(opfDoc) {
        var title = "";
        var manifest = new Map();
        var spine = [];
        var spineTocId = "";

        var titleNode = firstByTag(opfDoc, ["dc:title", "title"]);
        if (titleNode) {
          title = cleanText(titleNode.textContent);
        }

        var spineNode = byLocalName(opfDoc, "spine")[0];
        if (spineNode) {
          spineTocId = spineNode.getAttribute("toc") || "";
        }

        var items = byLocalName(opfDoc, "item");
        for (var i = 0; i < items.length; i += 1) {
          var item = items[i];
          if (!item.parentNode || localName(item.parentNode) !== "manifest") {
            continue;
          }
          var id = item.getAttribute("id") || "";
          var href = item.getAttribute("href") || "";
          if (!id || !href) {
            continue;
          }
          manifest.set(id, {
            id: id,
            href: href,
            mediaType: item.getAttribute("media-type") || "",
            properties: item.getAttribute("properties") || ""
          });
        }

        var itemRefs = byLocalName(opfDoc, "itemref");
        for (var j = 0; j < itemRefs.length; j += 1) {
          var itemref = itemRefs[j];
          if (!itemref.parentNode || localName(itemref.parentNode) !== "spine") {
            continue;
          }
          var idref = itemref.getAttribute("idref") || "";
          if (idref) {
            spine.push(idref);
          }
        }

        return {
          title: title,
          manifest: manifest,
          spine: spine,
          spineTocId: spineTocId
        };
      }

      async function parseToc(resolver, opfInfo, opfDir) {
        var manifest = opfInfo.manifest;
        var spineTocId = opfInfo.spineTocId;

        if (spineTocId && manifest.has(spineTocId)) {
          var tocItem = manifest.get(spineTocId);
          var ncxPath = resolveRelative(opfDir, tocItem.href);
          if (resolver.has(ncxPath)) {
            var ncxText = await resolver.readText(ncxPath);
            var ncxDoc = parseXml(ncxText);
            var navMap = byLocalName(ncxDoc, "navMap")[0];
            if (navMap) {
              return {
                source: "ncx",
                baseDir: dirname(ncxPath),
                items: parseNcxPoints(childrenByLocal(navMap, "navPoint"))
              };
            }
          }
        }

        var navItem = null;
        manifest.forEach(function (item) {
          if (navItem) {
            return;
          }
          if ((item.properties || "").split(/\s+/).indexOf("nav") >= 0) {
            navItem = item;
          }
        });

        if (navItem) {
          var navPath = resolveRelative(opfDir, navItem.href);
          if (resolver.has(navPath)) {
            var navText = await resolver.readText(navPath);
            var navDoc = parseXml(navText);
            var navNode = pickTocNavNode(navDoc);
            if (navNode) {
              var rootList = firstChildByLocal(navNode, ["ol", "ul"]) || byLocalName(navNode, "ol")[0] || byLocalName(navNode, "ul")[0];
              if (rootList) {
                return {
                  source: "nav",
                  baseDir: dirname(navPath),
                  items: parseNavList(rootList)
                };
              }
            }
          }
        }

        return {
          source: "spine-fallback",
          baseDir: opfDir,
          items: []
        };
      }

      function parseNcxPoints(nodes) {
        var out = [];
        for (var i = 0; i < nodes.length; i += 1) {
          var navPoint = nodes[i];
          var navLabel = firstChildByLocal(navPoint, ["navLabel"]);
          var textNode = navLabel ? firstChildByLocal(navLabel, ["text"]) : null;
          var contentNode = firstChildByLocal(navPoint, ["content"]);
          out.push({
            title: cleanText(textNode ? textNode.textContent : navLabel ? navLabel.textContent : "Untitled"),
            href: contentNode ? (contentNode.getAttribute("src") || "") : "",
            children: parseNcxPoints(childrenByLocal(navPoint, "navPoint"))
          });
        }
        return out;
      }

      function pickTocNavNode(doc) {
        var navNodes = byLocalName(doc, "nav");
        for (var i = 0; i < navNodes.length; i += 1) {
          var nav = navNodes[i];
          var role = (nav.getAttribute("role") || "").toLowerCase();
          var epubType = (nav.getAttribute("epub:type") || nav.getAttribute("type") || "").toLowerCase();
          if (role === "doc-toc" || epubType.indexOf("toc") >= 0) {
            return nav;
          }
          var attrs = nav.attributes || [];
          for (var k = 0; k < attrs.length; k += 1) {
            if (attrs[k].name && attrs[k].name.toLowerCase().indexOf("type") >= 0 && (attrs[k].value || "").toLowerCase().indexOf("toc") >= 0) {
              return nav;
            }
          }
        }
        return navNodes[0] || null;
      }

      function parseNavList(listNode) {
        var out = [];
        var liNodes = childrenByLocal(listNode, "li");
        for (var i = 0; i < liNodes.length; i += 1) {
          var li = liNodes[i];
          var labelNode = firstChildByLocal(li, ["a", "span", "p", "div"]);
          var listChild = firstChildByLocal(li, ["ol", "ul"]);
          out.push({
            title: cleanText(labelNode ? labelNode.textContent : li.textContent || "Untitled"),
            href: labelNode && localName(labelNode) === "a" ? (labelNode.getAttribute("href") || "") : "",
            children: listChild ? parseNavList(listChild) : []
          });
        }
        return out;
      }

      async function loadSpineChapters(resolver, opfInfo, opfDir, tocData) {
        var manifest = opfInfo.manifest;
        var spine = opfInfo.spine;
        var titleByPath = buildTocTitleMap(tocData.items, tocData.baseDir);
        var mediaTypeByPath = buildMediaTypeByPath(manifest, opfDir);
        var chapters = [];

        for (var i = 0; i < spine.length; i += 1) {
          setStatus("Loading chapter " + (i + 1) + " / " + spine.length + " ...");
          var idref = spine[i];
          if (!manifest.has(idref)) {
            continue;
          }
          var item = manifest.get(idref);
          var path = resolveRelative(opfDir, item.href);
          if (!resolver.has(path)) {
            continue;
          }

          var mediaType = (item.mediaType || "").toLowerCase();
          var isHtml = mediaType.indexOf("xhtml") >= 0 || mediaType.indexOf("html") >= 0 || /\.x?html?$/i.test(path);
          if (!isHtml) {
            continue;
          }

          var chapterText = await resolver.readText(path);
          var bodyHtml = extractBodyMarkup(chapterText);
          if (!bodyHtml) {
            continue;
          }

          var heading = titleByPath.get(path) || extractFirstHeading(chapterText) || stripExt(path.split("/").pop() || ("chapter-" + (i + 1)));
          var sectionPrefix = "ch" + (i + 1);
          var prepared = await prepareChapterHtml(bodyHtml, sectionPrefix, resolver, dirname(path), mediaTypeByPath);

          chapters.push({
            index: i + 1,
            path: path,
            title: heading,
            html: prepared.html,
            idMap: prepared.idMap
          });
        }

        return chapters;
      }

      function renderChapters(chapters) {
        contentBody.innerHTML = "";
        var sectionByPath = new Map();
        var idMapByPath = new Map();

        for (var i = 0; i < chapters.length; i += 1) {
          var chapter = chapters[i];
          var sectionId = "section-" + chapter.index;
          var displayTitle = chapter.title || stripExt(chapter.path.split("/").pop() || ("chapter-" + chapter.index));

          var article = document.createElement("article");
          article.className = "chapter";
          article.id = sectionId;

          var h2 = document.createElement("h2");
          h2.textContent = displayTitle;
          article.appendChild(h2);

          var content = document.createElement("div");
          content.className = "chapter-content";
          content.innerHTML = removeDuplicateLeadingHeading(chapter.html, displayTitle);
          article.appendChild(content);

          contentBody.appendChild(article);
          sectionByPath.set(chapter.path, sectionId);
          idMapByPath.set(chapter.path, chapter.idMap);
        }

        return {
          sectionByPath: sectionByPath,
          idMapByPath: idMapByPath
        };
      }

      function renderToc(tocData, chapters, maps) {
        var items = tocData.items && tocData.items.length ? tocData.items : buildSpineFallbackToc(chapters);
        if (!items.length) {
          tocWrap.innerHTML = "<div class=\"placeholder\">No table of contents generated.</div>";
          return;
        }

        activeTocLink = null;
        tocWrap.innerHTML = "";
        var tree = document.createElement("ul");
        tree.className = "toc-tree";
        tocWrap.appendChild(tree);

        var chapterByPath = new Map();
        for (var i = 0; i < chapters.length; i += 1) {
          chapterByPath.set(chapters[i].path, chapters[i]);
        }

        renderTocBranch(items, tree, tocData.baseDir || "", maps.sectionByPath, maps.idMapByPath, chapterByPath);
      }

      function renderTocBranch(items, parentEl, tocBaseDir, sectionByPath, idMapByPath, chapterByPath) {
        for (var i = 0; i < items.length; i += 1) {
          var item = items[i];
          var li = document.createElement("li");
          var row = document.createElement("div");
          row.className = "toc-row";

          var link = document.createElement("a");
          link.textContent = item.title || "Untitled";
          var refs = collectChapterRefsFromItem(item, tocBaseDir, sectionByPath, idMapByPath);
          if (refs.length > 0) {
            link.href = "javascript:void(0)";
            attachTocSelectHandler(link, item, refs, chapterByPath);
          } else {
            link.href = "javascript:void(0)";
            link.classList.add("disabled");
          }

          row.appendChild(link);

          li.appendChild(row);

          if (item.children && item.children.length) {
            var child = document.createElement("ul");
            child.className = "toc-tree";
            li.appendChild(child);
            renderTocBranch(item.children, child, tocBaseDir, sectionByPath, idMapByPath, chapterByPath);
          }

          parentEl.appendChild(li);
        }
      }

      function attachTocSelectHandler(link, item, refs, chapterByPath) {
        link.addEventListener("click", function (event) {
          event.preventDefault();

          if (activeTocLink && activeTocLink !== link) {
            activeTocLink.classList.remove("active");
          }
          activeTocLink = link;
          link.classList.add("active");

          renderSelectedChapters(refs, chapterByPath);
          setStatus("Showing: " + (item.title || "Untitled") + " (" + refs.length + " chapters)");
        });
      }

      function renderSelectedChapters(refs, chapterByPath) {
        contentBody.innerHTML = "";

        var rendered = 0;
        for (var i = 0; i < refs.length; i += 1) {
          var ref = refs[i];
          var chapter = chapterByPath.get(ref.path);
          if (!chapter) {
            continue;
          }
          var displayTitle = ref.title || chapter.title || stripExt(ref.path.split("/").pop() || ref.path);

          var article = document.createElement("article");
          article.className = "chapter";
          article.id = "selected-" + slugify(chapter.path) + "-" + i;

          var h2 = document.createElement("h2");
          h2.textContent = displayTitle;
          article.appendChild(h2);

          var content = document.createElement("div");
          content.className = "chapter-content";
          content.innerHTML = removeDuplicateLeadingHeading(chapter.html, displayTitle);
          article.appendChild(content);

          contentBody.appendChild(article);
          rendered += 1;
        }

        if (!rendered) {
          contentBody.innerHTML = "<div class=\"placeholder\">No displayable chapter content under this node.</div>";
        }

        var mainPanel = contentBody.parentElement;
        if (mainPanel && typeof mainPanel.scrollTo === "function") {
          mainPanel.scrollTo({ top: 0, behavior: "smooth" });
        } else if (mainPanel) {
          mainPanel.scrollTop = 0;
        }
      }

      function collectChapterRefsFromItem(rootItem, tocBaseDir, sectionByPath, idMapByPath) {
        var refs = [];
        var seen = new Set();

        walk(rootItem);
        return refs;

        function walk(node) {
          if (!node) {
            return;
          }

          var ref = resolveTargetRef(tocBaseDir, node.href || "");
          var path = "";

          if (!ref.external) {
            if (ref.path && sectionByPath.has(ref.path)) {
              path = ref.path;
            } else if (!ref.path && ref.fragment) {
              path = findChapterPathByFragment(ref.fragment, idMapByPath);
            }
          }

          if (path && !seen.has(path)) {
            seen.add(path);
            refs.push({
              path: path,
              title: cleanText(node.title || "")
            });
          }

          var children = node.children || [];
          for (var i = 0; i < children.length; i += 1) {
            walk(children[i]);
          }
        }
      }

      function findChapterPathByFragment(fragment, idMapByPath) {
        var matched = "";
        if (!fragment) {
          return matched;
        }
        idMapByPath.forEach(function (idMap, path) {
          if (!matched && idMap && idMap.has(fragment)) {
            matched = path;
          }
        });
        return matched;
      }

      function removeDuplicateLeadingHeading(html, title) {
        var source = html || "";
        if (!source) {
          return "";
        }

        var normalizedTitle = normalizeHeadingCompare(title);
        if (!normalizedTitle) {
          return source;
        }

        var parser = new DOMParser();
        var doc = parser.parseFromString("<!doctype html><html><body>" + source + "</body></html>", "text/html");
        var body = doc.body;
        if (!body) {
          return source;
        }

        var first = body.firstElementChild;
        while (first && isEmptyNode(first)) {
          var next = first.nextElementSibling;
          first.remove();
          first = next;
        }

        if (!first) {
          return body.innerHTML;
        }

        var firstHeading = body.querySelector("h1,h2,h3,h4,h5,h6");
        if (!firstHeading) {
          return body.innerHTML;
        }

        var normalizedFirst = normalizeHeadingCompare(firstHeading.textContent || "");
        if (normalizedFirst && normalizedFirst === normalizedTitle) {
          if (!hasMeaningfulContentBeforeNode(body, firstHeading)) {
            var parent = firstHeading.parentElement;
            firstHeading.remove();
            cleanupEmptyContainerUpwards(parent, body);
          }
        }

        return body.innerHTML;
      }

      function hasMeaningfulContentBeforeNode(root, targetNode) {
        var treeDoc = root && root.ownerDocument ? root.ownerDocument : document;
        if (!root || !targetNode || !treeDoc || !treeDoc.createTreeWalker || !window.NodeFilter) {
          return false;
        }

        var walker = treeDoc.createTreeWalker(
          root,
          window.NodeFilter.SHOW_ELEMENT | window.NodeFilter.SHOW_TEXT,
          null
        );

        var node = walker.nextNode();
        while (node) {
          if (node === targetNode) {
            return false;
          }

          if (node.nodeType === 3) {
            if ((node.nodeValue || "").replace(/\u00a0/g, "").trim()) {
              return true;
            }
          } else if (node.nodeType === 1) {
            var tag = localName(node);
            if (["img", "svg", "video", "audio", "table", "ul", "ol", "blockquote", "pre", "code", "hr"].indexOf(tag) >= 0) {
              return true;
            }
          }

          node = walker.nextNode();
        }

        return false;
      }

      function cleanupEmptyContainerUpwards(node, stopNode) {
        var current = node;
        while (current && current !== stopNode) {
          if (!isEmptyNode(current)) {
            break;
          }
          var parent = current.parentElement;
          current.remove();
          current = parent;
        }
      }

      function normalizeHeadingCompare(text) {
        var value = cleanText(text || "").toLowerCase();
        value = value.replace(/["'`“”‘’]+/g, "");
        value = value.replace(/[^a-z0-9\u4e00-\u9fff]+/g, "");
        return value;
      }

      function isEmptyNode(node) {
        if (!node || node.nodeType !== 1) {
          return true;
        }
        if (node.querySelector("img,svg,video,audio,table,ul,ol,blockquote,pre,code")) {
          return false;
        }
        var txt = (node.textContent || "").replace(/\u00a0/g, "").trim();
        return txt.length === 0;
      }

      function isEmptyBlock(node) {
        if (!node || node.nodeType !== 1) {
          return false;
        }
        var tag = localName(node);
        var allowed = ["p", "div", "span"];
        if (allowed.indexOf(tag) < 0) {
          return false;
        }
        if (node.querySelector("img,svg,video,audio,table,ul,ol,blockquote,pre,code")) {
          return false;
        }
        var txt = (node.textContent || "").replace(/\u00a0/g, "").trim();
        return txt.length === 0;
      }

      function resolveTargetRef(baseDir, href) {
        var raw = (href || "").trim();
        var hashIdx = raw.indexOf("#");
        var pathPart = hashIdx >= 0 ? raw.slice(0, hashIdx) : raw;
        var frag = hashIdx >= 0 ? decodeURIComponent(raw.slice(hashIdx + 1)) : "";

        if (/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(pathPart)) {
          return { external: true, path: pathPart, fragment: frag };
        }

        if (!pathPart) {
          return { external: false, path: "", fragment: frag };
        }

        return {
          external: false,
          path: resolveRelative(baseDir, pathPart),
          fragment: frag
        };
      }

      function resolveRelative(baseDir, hrefPath) {
        if (!hrefPath) {
          return normalizePath(baseDir || "");
        }
        if (hrefPath.indexOf("/") === 0) {
          return normalizePath(hrefPath.slice(1));
        }
        var base = baseDir ? baseDir + "/" : "";
        return normalizePath(base + hrefPath);
      }

      function dirname(path) {
        var norm = normalizePath(path);
        var idx = norm.lastIndexOf("/");
        return idx < 0 ? "" : norm.slice(0, idx);
      }

      function normalizePath(path) {
        var input = (path || "").replace(/\\/g, "/");
        var parts = input.split("/");
        var out = [];
        for (var i = 0; i < parts.length; i += 1) {
          var p = parts[i];
          if (!p || p === ".") {
            continue;
          }
          if (p === "..") {
            out.pop();
            continue;
          }
          out.push(p);
        }
        return out.join("/");
      }

      function parseXml(text) {
        var parser = new DOMParser();
        var xmlDoc = parser.parseFromString(text, "application/xml");
        if (!hasParserError(xmlDoc)) {
          return xmlDoc;
        }
        return parser.parseFromString(text, "text/html");
      }

      function hasParserError(doc) {
        return byLocalName(doc, "parsererror").length > 0;
      }

      function getBodyFromDoc(doc) {
        if (!doc) {
          return null;
        }
        if (doc.body) {
          return doc.body;
        }
        var bodyNodes = byLocalName(doc, "body");
        return bodyNodes[0] || null;
      }

      function getInnerMarkup(node) {
        if (!node) {
          return "";
        }
        if (typeof node.innerHTML === "string") {
          return node.innerHTML;
        }
        var serializer = new XMLSerializer();
        var out = "";
        for (var i = 0; i < node.childNodes.length; i += 1) {
          out += serializer.serializeToString(node.childNodes[i]);
        }
        return out;
      }

      function byLocalName(root, name) {
        if (!root || !name) {
          return [];
        }

        var result = [];
        var seen = new Set();

        var list1 = root.getElementsByTagName ? root.getElementsByTagName(name) : [];
        for (var i = 0; i < list1.length; i += 1) {
          if (!seen.has(list1[i])) {
            seen.add(list1[i]);
            result.push(list1[i]);
          }
        }

        if (root.getElementsByTagNameNS) {
          var list2 = root.getElementsByTagNameNS("*", name);
          for (var j = 0; j < list2.length; j += 1) {
            if (!seen.has(list2[j])) {
              seen.add(list2[j]);
              result.push(list2[j]);
            }
          }
        }

        return result;
      }

      function childrenByLocal(node, name) {
        if (!node || !node.childNodes) {
          return [];
        }
        var target = String(name || "").toLowerCase();
        var out = [];
        for (var i = 0; i < node.childNodes.length; i += 1) {
          var child = node.childNodes[i];
          if (child.nodeType !== 1) {
            continue;
          }
          if (localName(child) === target) {
            out.push(child);
          }
        }
        return out;
      }

      function firstChildByLocal(node, names) {
        if (!node || !node.childNodes) {
          return null;
        }
        var targets = (names || []).map(function (n) { return String(n).toLowerCase(); });
        for (var i = 0; i < node.childNodes.length; i += 1) {
          var child = node.childNodes[i];
          if (child.nodeType !== 1) {
            continue;
          }
          if (targets.indexOf(localName(child)) >= 0) {
            return child;
          }
        }
        return null;
      }

      function firstByTag(root, names) {
        for (var i = 0; i < names.length; i += 1) {
          var list = root.getElementsByTagName(names[i]);
          if (list && list.length) {
            return list[0];
          }
        }
        for (var j = 0; j < names.length; j += 1) {
          var local = names[j].indexOf(":") >= 0 ? names[j].split(":")[1] : names[j];
          var listNs = byLocalName(root, local);
          if (listNs.length) {
            return listNs[0];
          }
        }
        return null;
      }

      function localName(node) {
        return (node.localName || node.nodeName || "").toLowerCase().replace(/^.*:/, "");
      }

      function cleanText(text) {
        return (text || "").replace(/\s+/g, " ").trim();
      }

      function slugify(text) {
        var s = (text || "").toLowerCase().replace(/[^a-z0-9_\-:.]+/g, "-").replace(/^-+|-+$/g, "");
        return s || "id";
      }

      function stripExt(name) {
        return name.replace(/\.[^.]+$/, "");
      }
      function buildSpineFallbackToc(chapters) {
        return chapters.map(function (chapter) {
          return {
            title: chapter.title,
            href: chapter.path,
            children: []
          };
        });
      }

      function buildTocTitleMap(items, baseDir) {
        var map = new Map();
        walkToc(items, function (item) {
          if (!item.href) {
            return;
          }
          var ref = resolveTargetRef(baseDir, item.href);
          if (ref.path && !map.has(ref.path)) {
            map.set(ref.path, item.title || "");
          }
        });
        return map;
      }

      function walkToc(items, visit) {
        for (var i = 0; i < items.length; i += 1) {
          visit(items[i]);
          if (items[i].children && items[i].children.length) {
            walkToc(items[i].children, visit);
          }
        }
      }

      function extractBodyMarkup(raw) {
        var doc = parseXml(raw);
        var body = getBodyFromDoc(doc);
        if (body) {
          return getInnerMarkup(body);
        }
        var fallback = raw.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
        return fallback ? fallback[1] : "";
      }

      function extractFirstHeading(raw) {
        var doc = parseXml(raw);
        var body = getBodyFromDoc(doc) || doc;
        var tags = ["h1", "h2", "h3", "h4", "h5", "h6"];
        for (var i = 0; i < tags.length; i += 1) {
          var nodes = byLocalName(body, tags[i]);
          if (nodes.length) {
            var txt = cleanText(nodes[0].textContent);
            if (txt) {
              return txt;
            }
          }
        }
        return "";
      }

      async function prepareChapterHtml(rawHtml, prefix, resolver, chapterDir, mediaTypeByPath) {
        var parser = new DOMParser();
        var doc = parser.parseFromString("<!DOCTYPE html><html><body><div id=\"root\"></div></body></html>", "text/html");
        var root = doc.getElementById("root");
        root.innerHTML = rawHtml;

        var removeSelector = "script,style,meta,base,link[rel='stylesheet'],iframe,object,embed";
        var removeNodes = root.querySelectorAll(removeSelector);
        for (var i = 0; i < removeNodes.length; i += 1) {
          removeNodes[i].remove();
        }

        var idMap = new Map();
        var idNodes = root.querySelectorAll("[id]");
        for (var j = 0; j < idNodes.length; j += 1) {
          var oldId = idNodes[j].getAttribute("id") || "";
          if (!oldId) {
            continue;
          }
          var newId = prefix + "__" + slugify(oldId) + "__" + j;
          idMap.set(oldId, newId);
          idNodes[j].setAttribute("id", newId);
        }

        var hashLinks = root.querySelectorAll("a[href^='#']");
        for (var k = 0; k < hashLinks.length; k += 1) {
          var href = hashLinks[k].getAttribute("href") || "";
          var key = href.replace(/^#/, "");
          if (idMap.has(key)) {
            hashLinks[k].setAttribute("href", "#" + idMap.get(key));
          }
        }

        await rewriteEmbeddedMediaUrls(root, resolver, chapterDir, mediaTypeByPath);
        trimEmptyEdges(root, 12);

        return {
          html: root.innerHTML,
          idMap: idMap
        };
      }

      async function rewriteEmbeddedMediaUrls(root, resolver, chapterDir, mediaTypeByPath) {
        if (!root || !resolver) {
          return;
        }

        var attrTasks = [];
        var srcNodes = root.querySelectorAll("img[src],source[src],video[src],audio[src]");
        for (var i = 0; i < srcNodes.length; i += 1) {
          attrTasks.push(rewriteMediaAttr(srcNodes[i], "src", resolver, chapterDir, mediaTypeByPath));
        }

        var posterNodes = root.querySelectorAll("video[poster]");
        for (var j = 0; j < posterNodes.length; j += 1) {
          attrTasks.push(rewriteMediaAttr(posterNodes[j], "poster", resolver, chapterDir, mediaTypeByPath));
        }

        var svgImageNodes = root.querySelectorAll("image[href],image[xlink\\:href]");
        for (var k = 0; k < svgImageNodes.length; k += 1) {
          if (svgImageNodes[k].hasAttribute("href")) {
            attrTasks.push(rewriteMediaAttr(svgImageNodes[k], "href", resolver, chapterDir, mediaTypeByPath));
          }
          if (svgImageNodes[k].hasAttribute("xlink:href")) {
            attrTasks.push(rewriteMediaAttr(svgImageNodes[k], "xlink:href", resolver, chapterDir, mediaTypeByPath));
          }
        }

        await Promise.all(attrTasks);

        var srcsetNodes = root.querySelectorAll("img[srcset],source[srcset]");
        for (var n = 0; n < srcsetNodes.length; n += 1) {
          var srcset = srcsetNodes[n].getAttribute("srcset") || "";
          var rewrittenSrcset = await rewriteSrcsetValue(srcset, resolver, chapterDir, mediaTypeByPath);
          if (rewrittenSrcset) {
            srcsetNodes[n].setAttribute("srcset", rewrittenSrcset);
          }
        }
      }

      async function rewriteMediaAttr(node, attrName, resolver, chapterDir, mediaTypeByPath) {
        if (!node || !attrName) {
          return;
        }

        var raw = (node.getAttribute(attrName) || "").trim();
        if (!raw) {
          return;
        }

        var rewritten = await resolveEmbeddedMediaUrl(raw, resolver, chapterDir, mediaTypeByPath);
        if (rewritten) {
          node.setAttribute(attrName, rewritten);
        }
      }

      async function rewriteSrcsetValue(value, resolver, chapterDir, mediaTypeByPath) {
        var input = (value || "").trim();
        if (!input) {
          return "";
        }

        var entries = input.split(",");
        var out = [];
        for (var i = 0; i < entries.length; i += 1) {
          var token = entries[i].trim();
          if (!token) {
            continue;
          }

          var splitAt = token.search(/\s/);
          var urlPart = splitAt < 0 ? token : token.slice(0, splitAt);
          var descriptor = splitAt < 0 ? "" : token.slice(splitAt).trim();
          var rewritten = await resolveEmbeddedMediaUrl(urlPart, resolver, chapterDir, mediaTypeByPath);

          if (!rewritten) {
            out.push(token);
            continue;
          }
          out.push(descriptor ? rewritten + " " + descriptor : rewritten);
        }

        return out.join(", ");
      }

      async function resolveEmbeddedMediaUrl(rawUrl, resolver, chapterDir, mediaTypeByPath) {
        var parsed = splitResourceUrl(rawUrl || "");
        if (!parsed.path || isNonLocalUrl(parsed.path)) {
          return "";
        }

        var resolvedPath = resolveRelative(chapterDir || "", parsed.path);
        if (!resolvedPath || !resolver.has(resolvedPath)) {
          return "";
        }

        var mediaUrl = await getOrCreateMediaAssetUrl(resolver, resolvedPath, mediaTypeByPath);
        if (!mediaUrl) {
          return "";
        }

        return mediaUrl + parsed.suffix;
      }

      function splitResourceUrl(raw) {
        var text = (raw || "").trim();
        var hashIdx = text.indexOf("#");
        var beforeHash = hashIdx >= 0 ? text.slice(0, hashIdx) : text;
        var hashSuffix = hashIdx >= 0 ? text.slice(hashIdx) : "";

        var queryIdx = beforeHash.indexOf("?");
        var path = queryIdx >= 0 ? beforeHash.slice(0, queryIdx) : beforeHash;
        var querySuffix = queryIdx >= 0 ? beforeHash.slice(queryIdx) : "";

        return {
          path: path,
          suffix: querySuffix + hashSuffix
        };
      }

      function isNonLocalUrl(path) {
        var value = (path || "").trim().toLowerCase();
        if (!value) {
          return true;
        }
        if (value.indexOf("//") === 0) {
          return true;
        }
        if (value.indexOf("data:") === 0 || value.indexOf("blob:") === 0 || value.indexOf("#") === 0) {
          return true;
        }
        if (/^[a-z][a-z0-9+.-]*:/.test(value)) {
          return true;
        }
        return false;
      }

      async function getOrCreateMediaAssetUrl(resolver, path, mediaTypeByPath) {
        var normPath = normalizePath(path);
        if (mediaAssetUrlCache.has(normPath)) {
          return mediaAssetUrlCache.get(normPath);
        }

        try {
          var bytes = await resolver.readBinary(normPath);
          var mediaType = (mediaTypeByPath && mediaTypeByPath.get(normPath)) || guessMediaType(normPath);
          var blob = new Blob([bytes], { type: mediaType || "application/octet-stream" });
          var objectUrl = URL.createObjectURL(blob);
          mediaAssetUrlCache.set(normPath, objectUrl);
          mediaAssetObjectUrls.push(objectUrl);
          return objectUrl;
        } catch (error) {
          return "";
        }
      }

      function revokeMediaAssetUrls() {
        for (var i = 0; i < mediaAssetObjectUrls.length; i += 1) {
          try {
            URL.revokeObjectURL(mediaAssetObjectUrls[i]);
          } catch (error) {
            // Ignore revoke failures for stale object URLs.
          }
        }
        mediaAssetObjectUrls = [];
        mediaAssetUrlCache.clear();
      }

      function buildMediaTypeByPath(manifest, opfDir) {
        var map = new Map();
        if (!manifest || !manifest.forEach) {
          return map;
        }

        manifest.forEach(function (item) {
          if (!item || !item.href) {
            return;
          }
          var path = resolveRelative(opfDir || "", item.href);
          map.set(path, item.mediaType || "");
        });
        return map;
      }

      function guessMediaType(path) {
        var lower = (path || "").toLowerCase();
        if (/\.avif$/.test(lower)) { return "image/avif"; }
        if (/\.bmp$/.test(lower)) { return "image/bmp"; }
        if (/\.gif$/.test(lower)) { return "image/gif"; }
        if (/\.ico$/.test(lower)) { return "image/x-icon"; }
        if (/\.jpe?g$/.test(lower)) { return "image/jpeg"; }
        if (/\.png$/.test(lower)) { return "image/png"; }
        if (/\.svg$/.test(lower)) { return "image/svg+xml"; }
        if (/\.tiff?$/.test(lower)) { return "image/tiff"; }
        if (/\.webp$/.test(lower)) { return "image/webp"; }
        if (/\.mp3$/.test(lower)) { return "audio/mpeg"; }
        if (/\.m4a$/.test(lower)) { return "audio/mp4"; }
        if (/\.ogg$/.test(lower)) { return "audio/ogg"; }
        if (/\.wav$/.test(lower)) { return "audio/wav"; }
        if (/\.mp4$/.test(lower)) { return "video/mp4"; }
        if (/\.webm$/.test(lower)) { return "video/webm"; }
        return "application/octet-stream";
      }

      function trimEmptyEdges(root, maxCount) {
        var count = 0;
        while (root.firstElementChild && count < maxCount && isEmptyBlock(root.firstElementChild)) {
          root.firstElementChild.remove();
          count += 1;
        }
        count = 0;
        while (root.lastElementChild && count < maxCount && isEmptyBlock(root.lastElementChild)) {
          root.lastElementChild.remove();
          count += 1;
        }
      }
    })();
  </script>
</body>
</html>
